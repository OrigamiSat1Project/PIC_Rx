//#include <stdio.h>
//#include <stdlib.h>
#include <string.h>
#include <xc.h>
#include <PIC16LF877A.h>
#include "typeDefine.h"
#include "pinDefine.h"
#include "InitMPU.h"
#include "time.h"
#include "UART.h"
#include "decodeAX25.h"
#include "I2C.h"
#include "EEPROM.h"
#include "FMCW.h"
#include "EPS.h"
#include "timer.h"


// PIC16F887 Configuration Bit Settings
#pragma config FOSC     = HS        // Oscillator Selection bits (HS oscillator)
#pragma config WDTE     = OFF       // Watchdog Timer Enable bit (WDT disabled)
#pragma config PWRTE    = ON        // Power-up Timer Enable bit (PWRT enabled)
#pragma config BOREN    = OFF       // Brown-out Reset Enable bit (BOR enabled)
#pragma config LVP      = OFF       // Low-Voltage (Single-Supply) In-Circuit Serial Programming Enable bit (RB3 is digital I/O, HV on MCLR must be used for programming)
#pragma config CPD      = OFF       // Data EEPROM Memory Code Protection bit (Data EEPROM code protection off)
#pragma config WRT      = OFF       // Flash Program Memory Write Enable bits (Write protection off; all program memory may be written to by EECON control)
#pragma config CP       = OFF       // Flash Program Memory Code Protection bit (Code protection off)
// #pragma config statements should precede project file includes.
// Use project enums instead of #define for ON and OFF.

//extern UBYTE commandData[DATA_SIZE];

void main(void) {
    
    /*---Initialization---*/
    /*----------------------------------------------------------------------*/
    InitSerial();
    InitMPU();
    InitI2CMaster(I2Cbps);
    initTimer();
    //InitWDT();
    
    LED_WHITE = 1;              //for debugging of init
    __delay_ms(2000);           //wait until 5V is generated by EPS
    
    //PLL setting (common Phase-Locked Loop)
    FMTX(FMTX_Nref, FMTX_Nprg);
    CWTX(CWTX_Nref, CWTX_Nprg);
    FMRX(FMRX_Nref, FMRX_Nprg);
    
    LED_WHITE = 0;              //for debugging of PLL setting
    __delay_ms(500);           //wait for circuit of PLL
    
    //define command ID
    //UBYTE lastCommandID;        //ID of last uplink command
    
    //WDT = 1; // kick watchdog

    RB3 = 1;
    RC5 = 1;    //5R8G on
    putChar('A');
    
    while(1){
        putChar('B');
        /*measure the runtime of the getBitLoop*/    //for normal run not needed
        /*------------------------------------------------------------------*/
        //while(1){
            //getbit();
            //debugLEDyellow();   //6us
        //}
        
        
        /*---Receive command data---*/ 
        /*------------------------------------------------------------------*/
        UBYTE commandData[DATA_SIZE];         //data of uplink command
//        UBYTE *commandData;         //data of uplink command
//        UBYTE commandID;            //ID of uplink command
        //for information on EEPROM see data sheet: 24LC1025        
        UBYTE B0select;             //control byte B0 of EEPROM
        UBYTE wHighAddress;         //address high byte of EEPROM
        UBYTE wLowAddress;          //address low byte of EEPROM
        UBYTE mainControlByte;      //control byte of main EEPROM
        UBYTE subControlByte;       //control byte of sub EEPROM
        
        
        UBYTE downlinkTimes;       //downlink times of received command
//        receiveDataPacket();
        receiveDataPacket(commandData);
//        commandData = receiveDataPacket();
        
//        putString(commandData);
//        putChar('C');
        
//        commandID = commandData[1];
//        
//        putChar(commandID);
//        putCrLf();
//        putChar(lastCommandID);
//        putCrLf();
////        if (commandID == lastCommandID) continue;       //same uplink command
//        lastCommandID = commandID;                      //update command ID
        
//        for (int i = 0; i<5;i++){
//            LED_WHITE = 1;
//            __delay_ms(2000);
//            LED_WHITE = 0;
//            __delay_ms(1000);
//        }
        putChar('D');
        LED_WHITE = 1;
        __delay_ms(500);
        LED_WHITE = 0;
        
        B0select = commandData[19];
        wHighAddress = commandData[20];
        wLowAddress = commandData[21];
        downlinkTimes = commandData[22];
        mainControlByte = MAIN_EEPROM_ADDRESS | B0select;
        subControlByte = SUB_EEPROM_ADDRESS | B0select;
        
        //printf("%s\r\n", commandData); //used for debugging with computer
                
//        LED_WHITE = 1; //debugging receive command from ground station
//        __delay_ms(100);
//        LED_WHITE = 0;

        
        /*---Write uplink command in EEPROM---*/
        /*------------------------------------------------------------------*/
        WriteToEEPROM(mainControlByte,wHighAddress,wLowAddress,commandData);
        WriteToEEPROM(subControlByte,wHighAddress,wLowAddress,commandData);
        putChar('S');
        
        /*---Send address using UART to OBC and TXCOBC---*/
        /*------------------------------------------------------------------*/
        sendCommand('g', 'u', B0select, wHighAddress, wLowAddress, downlinkTimes);
        putChar('G');
        
        for(int i=0; i<DATA_SIZE; i++){
            putChar(commandData[i]);
        }
        putChar('H');
        /*---Define if command target is RXCOBC 'R' and read in task target ---*/
        /*------------------------------------------------------------------*/
        if(commandData[0]=='R'){                //command target = PIC_RX
            //Task target
            if(commandData[2] == 'r'){          //task target =  PIC_RX
                // Command type
                switch(commandData[3]){
                case 'E': /*EPS kill*/
                    Reset_EPS();
                    __delay_ms(5000);
                    //?¿½È‰ï¿½?¿½Ìï¿½?¿½?¿½?¿½Íï¿½?¿½?¿½?¿½Ý’èŽž?¿½Æ•Ï‰ï¿½?¿½?¿½?¿½Ä‚ï¿½?¿½é‚½?¿½ß‚ï¿½?¿½?¿½?¿½x?¿½?¿½`
                    //?¿½{?¿½?¿½?¿½È‚ï¿½Ï‰ï¿½?¿½?¿½?¿½é•¶?¿½?¿½?¿½?¿½?‘¼‚É—p?¿½Ó‚ï¿½?¿½?¿½?¿½Ù‚ï¿½?¿½?¿½?¿½Ç‚ï¿½?¿½?¿½?¿½?¿½?¿½?¿½?¿½È‚ï¿½
                    // values for Nprg are changed in setNprg function so they have to be reset
                    //TODO: make seperate function for set-up
                    int FMTX_Nprg[5]     =   {8,7,5,0,1};   // Nprg = 87300 = Ftx / 0.05 [436.500MHz]
                    int CWTX_Nprg[5]     =   {0,1,4,0,0};   // Nprg = 1747(* see 301ACWPLL-20080520.pdf *) [436.750MHz]
                    int FMRX_Nprg[5]     =   {2,4,9,1,6};   // Nprg = 24887 = (Frx - 21.4) / 0.05 [145.835MHz]
                    //reset PLL setting (because it gets lost during shutdown)
                    FMTX(FMTX_Nref, FMTX_Nprg);
                    CWTX(CWTX_Nref, CWTX_Nprg);
                    FMRX(FMRX_Nref, FMRX_Nprg);
                    __delay_ms(500);
                    break;
                case 'I':
                    // I2C mode
                    break;
                case '3':
                    // 
                    break;
                case 'N':
                    // NanoMind
                    break;
                case 'T':
                    // send TXPIC by I2C
                    break;
                default:
                    // error
                    break;
                }

            }else if(commandData[2] == 't'){      //task target =  PIC_TX       

            }else if(commandData[2] == 'o'){      //task target =  OBC       

            }else if(commandData[2] == '5'){      //task target =  5R8G       

            }
        }else{
            //debugging if coomand target is not RXCOBC
            LED_WHITE = 1;  
            __delay_ms(1000);
            LED_WHITE = 0;
        }
        
    
        __delay_ms(500);
    }
    return;
}
